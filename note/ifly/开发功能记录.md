# 网关

## 网关配置URL级别超时时间

SpringCloud 整合Zuul 在使用Ribbon（RibbonRoutingFilter）请求，有关超时时间最细粒度的配置是到应用

```
#serviceId 如果不指定到具体服务 配置全局的话 直接删除此级别
service-consumer:
  # 负载均衡（实际请求）的时间 
  ribbon:
    ReadTimeout: 1000
    ConnectTimeout: 1000
# 熔断时间
hystrix:
  command:
  	#serviceId 如果不指定到具体服务 配置全局的话 此处为default
    service-consumer:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 3000
```

- service-consumer 是routes（路由规则）配置中的serviceId



下面是计算hystrixTimeout的代码实现，如果没有配置hystrixTimeout则根据ribbon的一些配置参数计算。

两个时间都要满足，请求才能不超时。从默认的实现看也是这样，如果显示配置了hystrixTimeout的值且小于ribbonTimeout 会产生一个警告日志。AbstractRibbonCommand类实现如下：

```
protected static int getHystrixTimeout(IClientConfig config, String commandKey) {
	// 默认实现 ribbonTimeout = (ribbonReadTimeout + ribbonConnectTimeout)* (maxAutoRetries + 1) * (maxAutoRetriesNextServer + 1)
	int ribbonTimeout = getRibbonTimeout(config, commandKey);
	DynamicPropertyFactory dynamicPropertyFactory = DynamicPropertyFactory
			.getInstance();
	int defaultHystrixTimeout = dynamicPropertyFactory.getIntProperty(
			"hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds",
			0).get();
	int commandHystrixTimeout = dynamicPropertyFactory
			.getIntProperty("hystrix.command." + commandKey
					+ ".execution.isolation.thread.timeoutInMilliseconds", 0)
			.get();
	int hystrixTimeout;
	if (commandHystrixTimeout > 0) {
		hystrixTimeout = commandHystrixTimeout;
	}
	else if (defaultHystrixTimeout > 0) {
		hystrixTimeout = defaultHystrixTimeout;
	}
	else {
		hystrixTimeout = ribbonTimeout;
	}
	# 警告日志
	if (hystrixTimeout < ribbonTimeout) {
		LOGGER.warn("The Hystrix timeout of " + hystrixTimeout + "ms for the command "
				+ commandKey
				+ " is set lower than the combination of the Ribbon read and connect timeout, "
				+ ribbonTimeout + "ms.");
	}
	return hystrixTimeout;
}
```





提供的配置不能解决需求，百度一下[相关解决方案](https://segmentfault.com/a/1190000009979859)

RibbonRoutingFilter 是zuul中根据serviceId方式请求的类，核心方法如下：

```
// run 方式是filter满足执行条件后执行逻辑的方法
public Object run() {
	RequestContext context = RequestContext.getCurrentContext();
	this.helper.addIgnoredHeaders();
	try {
		RibbonCommandContext commandContext = buildCommandContext(context);
		ClientHttpResponse response = forward(commandContext);
		setResponse(response);
		return response;
	}
	catch (ZuulException ex) {
		throw new ZuulRuntimeException(ex);
	}
	catch (Exception ex) {
		throw new ZuulRuntimeException(ex);
	}
}

protected ClientHttpResponse forward(RibbonCommandContext context) throws Exception {
	Map<String, Object> info = this.helper.debug(context.getMethod(),
			context.getUri(), context.getHeaders(), context.getParams(), context.getRequestEntity());
			
	// RibbonCommand 是Ribbon整合Hystrix的一个命令，请求的所有参数在ribbonCommandFactory.create(context)这一步已经封装好，command.execute()已经开始执行请求了。
	RibbonCommand command = this.ribbonCommandFactory.create(context);
	try {
		ClientHttpResponse response = command.execute();
		this.helper.appendDebug(info, response.getRawStatusCode(),
				response.getHeaders());
		return response;
	}
	catch (HystrixRuntimeException ex) {
		return handleException(info, ex);
	}
}
```

HttpClientRibbonCommandFactory中创建Command的方法如下：直接 new HttpClientRibbonCommand

```
public HttpClientRibbonCommand create(final RibbonCommandContext context) {
	FallbackProvider zuulFallbackProvider = getFallbackProvider(
			context.getServiceId());
	final String serviceId = context.getServiceId();
	final RibbonLoadBalancingHttpClient client = this.clientFactory
			.getClient(serviceId, RibbonLoadBalancingHttpClient.class);
	client.setLoadBalancer(this.clientFactory.getLoadBalancer(serviceId));

	return new HttpClientRibbonCommand(serviceId, client, context, zuulProperties,
			zuulFallbackProvider, clientFactory.getClientConfig(serviceId));
}
```

HttpClientRibbonCommand中创建Request的方法如下：直接 new RibbonApacheHttpRequest

```
protected RibbonApacheHttpRequest createRequest() throws Exception {
	return new RibbonApacheHttpRequest(this.context);
}
```

> RibbonRoutingFilter中ribbonCommandFactory是从IOC容器中注入的，RibbonCommandFactory创建HttpClientRibbonCommand，HttpClientRibbonCommand创建RibbonApacheHttpRequest都是直接new的。



RibbonApacheHttpRequest创建request的方法如下：

```
public HttpUriRequest toRequest(final RequestConfig requestConfig) {
	final RequestBuilder builder = RequestBuilder.create(this.context.getMethod());
	builder.setUri(this.uri);
	for (final String name : this.context.getHeaders().keySet()) {
		final List<String> values = this.context.getHeaders().get(name);
		for (final String value : values) {
			builder.addHeader(name, value);
		}
	}

	for (final String name : this.context.getParams().keySet()) {
		final List<String> values = this.context.getParams().get(name);
		for (final String value : values) {
			builder.addParameter(name, value);
		}
	}

	if (this.context.getRequestEntity() != null) {
		final BasicHttpEntity entity;
		entity = new BasicHttpEntity();
		entity.setContent(this.context.getRequestEntity());
		// if the entity contentLength isn't set, transfer-encoding will be set
		// to chunked in org.apache.http.protocol.RequestContent. See gh-1042
		Long contentLength = this.context.getContentLength();
		if ("GET".equals(this.context.getMethod())
				&& (contentLength == null || contentLength < 0)) {
			entity.setContentLength(0);
		}
		else if (contentLength != null) {
			entity.setContentLength(contentLength);
		}
		builder.setEntity(entity);
	}

    // 这里预留了一个自定义接口RequestCustomizers在生成RibbonRoutingFilter实例的时候可以注入 但是这里只能修改一些请求header信息 超时参数又会被下面的setConfig给覆盖掉
	customize(this.context.getRequestCustomizers(), builder);

	builder.setConfig(requestConfig);
	return builder.build();
}

```

在使用RequestCustomizers走不通之后只能扩展此类，最后使用扩展的类创建request

```
@Slf4j
class CustomRibbonApacheHttpRequest extends RibbonApacheHttpRequest {

    private final UrlCustomProperties urlCustomProperties;

    public CustomRibbonApacheHttpRequest(RibbonCommandContext context, UrlCustomProperties urlCustomProperties) {
        super(context);
        this.urlCustomProperties = urlCustomProperties;
    }

    @Override
    public HttpUriRequest toRequest(RequestConfig requestConfig) {
        HttpUriRequest request = super.toRequest(requestConfig);

        // 满足配置 重新设置请求的超时时间
        if (isMatch(context, urlCustomProperties) && request instanceof HttpRequestBase) {
            HttpRequestBase requestBase = (HttpRequestBase) request;
            RequestConfig.Builder builder = RequestConfig.copy(requestConfig);

            if (urlCustomProperties.getTimeConfig().getConnectTimeout() > 0) {
                builder.setConnectTimeout(urlCustomProperties.getTimeConfig().getConnectTimeout());
            }
            if (urlCustomProperties.getTimeConfig().getSocketTimeout() > 0) {
                builder.setSocketTimeout(urlCustomProperties.getTimeConfig().getSocketTimeout());
            }

            RequestConfig config = builder.build();
            requestBase.setConfig(config);
            log.info("ribbon: 更新[{}]{}超时时间 ConnectTimeout = {}, SocketTimeout = {}", context.getServiceId(), uri.getRawPath(), config.getConnectTimeout(), config.getSocketTimeout());
        }

        return request;
    }

}
```

其中RibbonTimeoutProperties是一个自定义的配置项包装类，配置项格式如下：

```
url-custom:
    time-config:
        connect-timeout: 2000
        socket-timeout: 120000
        urlMap:
            ima-management:
                - '/{version}/pt/client/file/upload'
```

> CustomRibbonApacheHttpRequest继承类原有的RibbonApacheHttpRequest类，因为我发现再调用父类的toRequest方法之后依然可以重新setConfig。这样就不用把父类中原有的逻辑再复制一份，只需匹配到我的配置项之后，重新设置ConnectTimeout和SocketTimeout即可。至此，只需要最后使用扩展的类就可以实现修改Ribbon请求时候的两个超时参数。



回到一开始提到知识，如果只是Ribbon超时时间足够长，Hystrix熔断时间较短，一样不成功。回到上面AbstractRibbonCommand类getHystrixTimeout的方法，只能在调用这个方法的方法里做修改:

```
private static HystrixCommandProperties.Setter createSetter(IClientConfig config, String commandKey, ZuulProperties zuulProperties,
                                                                RibbonCommandContext context, UrlCustomProperties urlCustomProperties, boolean isMatch) {
	int hystrixTimeout = getHystrixTimeout(config, commandKey);
	/*
	 * 重新设置hystrix的超时时间 如果不设置且小于ribbon超时时间 那么配置的接口的超时时间一样没意义
	 * 这里暂时设置为 SocketTimeout + ConnectTimeout
	 */
	if (isMatch && hystrixTimeout < urlCustomProperties.getTimeConfig().getSocketTimeout() + urlCustomProperties.getTimeConfig().getConnectTimeout()) {
		final String serviceId = context.getServiceId();
		final String url = context.getUri();
		hystrixTimeout = urlCustomProperties.getTimeConfig().getSocketTimeout() + urlCustomProperties.getTimeConfig().getConnectTimeout();
		log.info("hystrix: 更新[{}]{}超时时间 {}", serviceId, url, hystrixTimeout);
	}

	return HystrixCommandProperties.Setter()
			.withExecutionIsolationStrategy(zuulProperties.getRibbonIsolationStrategy())
			.withExecutionTimeoutInMilliseconds(hystrixTimeout);
}
```

if里面是添加的逻辑，其他的都不变。因为这些逻辑都是在构造方法里调用的，所以定义的都是static方法，扩展的类CustomHttpClientRibbonCommand不得不复制一些AbstractRibbonCommand类放到自己类中，因为父类的方法定义的都protected。

到此，两个方面的参数都重新设置了，开始测试。在使用默认配置和配置了全局的ribbon和hystrix的超时时间后都没问题，在配置了应用级别后，出现了hystrix超时的异常。在确定了计算的hystrixTimeout没问题之后，debug代码，跟踪这个参数最后怎么设置的，最后在父类AbstractCommand的构造方法中发现了一个方法，原来这里做了一个map缓存，如果缓存中有这个应用的配置，就不会使用形参。

```
public static HystrixCommandProperties getCommandProperties(HystrixCommandKey key, HystrixCommandProperties.Setter builder) {
	HystrixPropertiesStrategy hystrixPropertiesStrategy = HystrixPlugins.getInstance().getPropertiesStrategy();
	String cacheKey = hystrixPropertiesStrategy.getCommandPropertiesCacheKey(key, builder);
	if (cacheKey != null) {
		HystrixCommandProperties properties = commandProperties.get(cacheKey);
		if (properties != null) {
			return properties;
		} else {
			if (builder == null) {
				builder = HystrixCommandProperties.Setter();
			}
			// create new instance
			properties = hystrixPropertiesStrategy.getCommandProperties(key, builder);
			// cache and return
			HystrixCommandProperties existing = commandProperties.putIfAbsent(cacheKey, properties);
			if (existing == null) {
				return properties;
			} else {
				return existing;
			}
		}
	} else {
		// no cacheKey so we generate it with caching
		return hystrixPropertiesStrategy.getCommandProperties(key, builder);
	}
}
```

所以只能在传入的HystrixCommandKey做手脚，针对配置了url级别超时的请求，不使用默认的key。这里第一版的实现是每个接口一个key，但其实公用一个时间配置，所以最后修改为一个固定的key。可以根据需求修改为接口维度、应用维度，清空缓存key的Listener跟着调整就可以。

```
private static String getCommandKey(String commandKey, RibbonCommandContext context, UrlCustomProperties urlCustomProperties) {
	return isMatch(context, urlCustomProperties) ? KEY : commandKey;
}
```

因为有缓存，所以为了支持配置项热更新，在配置项修改后要清空该key

```
@Slf4j
public class HystrixConfigRefreshListener {

    private static final String FIELD_COMMAND_PROPERTIES = "commandProperties";

    @EventListener
    public void refresh(EnvironmentChangeEvent event) {
        List<String> keys = event.getKeys().stream().filter(key -> key.startsWith(PREFIX)).collect(Collectors.toList());
        if (CollectionUtils.isEmpty(keys)) {
            return;
        }

        log.info("配置项刷新: {}", keys);

        try {
            Field field = HystrixPropertiesFactory.class.getDeclaredField(FIELD_COMMAND_PROPERTIES);
            ReflectionUtils.makeAccessible(field);
            Object obj = field.get(null);

            ConcurrentHashMap<String, HystrixCommandProperties> map = (ConcurrentHashMap<String, HystrixCommandProperties>) obj;
            if (map.containsKey(KEY)) {
                map.remove(KEY);
                log.info("hystrix配置缓存删除 {}", KEY);
            }

            log.info("更新hystrix配置缓存成功");
        } catch (NoSuchFieldException | IllegalAccessException e) {
            log.error("更新hystrix配置缓存失败", e);
        }
    }

}
```

至此扩展的CustomHttpClientRibbonCommand和CustomRibbonApacheHttpRequest类的扩展逻辑代码已贴上，CustomHttpClientRibbonCommandFactory的代码如下：

```
class CustomHttpClientRibbonCommandFactory extends AbstractRibbonCommandFactory {

    private final SpringClientFactory clientFactory;
    private final ZuulProperties zuulProperties;
    private final UrlCustomProperties urlCustomProperties;

    public CustomHttpClientRibbonCommandFactory(SpringClientFactory clientFactory, ZuulProperties zuulProperties, Set<FallbackProvider> fallbackProviders,
                                                UrlCustomProperties urlCustomProperties) {
        super(fallbackProviders != null ? fallbackProviders : Collections.emptySet());
        this.clientFactory = clientFactory;
        this.zuulProperties = zuulProperties;
        this.urlCustomProperties = urlCustomProperties;
    }

    @Override
    public RibbonCommand create(RibbonCommandContext context) {
        FallbackProvider fallbackProvider = getFallbackProvider(context.getServiceId());
        final String serviceId = context.getServiceId();
        final RibbonLoadBalancingHttpClient client = clientFactory.getClient(serviceId, RibbonLoadBalancingHttpClient.class);
        client.setLoadBalancer(clientFactory.getLoadBalancer(serviceId));
        final IClientConfig config = clientFactory.getClientConfig(serviceId);

        return new CustomHttpClientRibbonCommand(serviceId, client, context, zuulProperties,
                fallbackProvider, config, urlCustomProperties);
    }

}
```

三个扩展类逻辑就是这些。默认的RibbonCommandFactory有几种实现，代码如下。**当前的扩展只是针对使用HttpClientRibbonCommandFactory的场景**，如果使用其他方式，同样方式扩展即可。

*这里解决的场景是网关调用一个层级服务超时的情况。如果网关->A->B，A调用B服务超时的情况不在此场景内。*

```
public class RibbonCommandFactoryConfiguration {

	@Configuration
	@ConditionalOnRibbonRestClient
	protected static class RestClientRibbonConfiguration {

		@Autowired(required = false)
		private Set<FallbackProvider> zuulFallbackProviders = Collections.emptySet();

		@Bean
		@ConditionalOnMissingBean
		public RibbonCommandFactory<?> ribbonCommandFactory(
				SpringClientFactory clientFactory, ZuulProperties zuulProperties) {
			return new RestClientRibbonCommandFactory(clientFactory, zuulProperties,
					zuulFallbackProviders);
		}

	}

	@Target({ ElementType.TYPE, ElementType.METHOD })
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Conditional(OnRibbonHttpClientCondition.class)
	@interface ConditionalOnRibbonHttpClient {

	}

	private static class OnRibbonHttpClientCondition extends AnyNestedCondition {

		OnRibbonHttpClientCondition() {
			super(ConfigurationPhase.PARSE_CONFIGURATION);
		}

		@ConditionalOnProperty(name = "ribbon.httpclient.enabled", matchIfMissing = true)
		static class RibbonProperty {

		}

	}

	@Target({ ElementType.TYPE, ElementType.METHOD })
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Conditional(OnRibbonOkHttpClientCondition.class)
	@interface ConditionalOnRibbonOkHttpClient {

	}

	@Configuration
	@ConditionalOnRibbonOkHttpClient
	@ConditionalOnClass(name = "okhttp3.OkHttpClient")
	protected static class OkHttpRibbonConfiguration {

		@Autowired(required = false)
		private Set<FallbackProvider> zuulFallbackProviders = Collections.emptySet();

		@Bean
		@ConditionalOnMissingBean
		public RibbonCommandFactory<?> ribbonCommandFactory(
				SpringClientFactory clientFactory, ZuulProperties zuulProperties) {
			return new OkHttpRibbonCommandFactory(clientFactory, zuulProperties,
					zuulFallbackProviders);
		}

	}

	@Configuration
	@ConditionalOnRibbonHttpClient
	protected static class HttpClientRibbonConfiguration {

		@Autowired(required = false)
		private Set<FallbackProvider> zuulFallbackProviders = Collections.emptySet();

		@Bean
		@ConditionalOnMissingBean
		public RibbonCommandFactory<?> ribbonCommandFactory(
				SpringClientFactory clientFactory, ZuulProperties zuulProperties) {
			return new HttpClientRibbonCommandFactory(clientFactory, zuulProperties,
					zuulFallbackProviders);
		}

	}

	private static class OnRibbonOkHttpClientCondition extends AnyNestedCondition {

		OnRibbonOkHttpClientCondition() {
			super(ConfigurationPhase.PARSE_CONFIGURATION);
		}

		@ConditionalOnProperty("ribbon.okhttp.enabled")
		static class RibbonProperty {

		}

	}

	@Target({ ElementType.TYPE, ElementType.METHOD })
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Conditional(OnRibbonRestClientCondition.class)
	@interface ConditionalOnRibbonRestClient {

	}

	private static class OnRibbonRestClientCondition extends AnyNestedCondition {

		OnRibbonRestClientCondition() {
			super(ConfigurationPhase.PARSE_CONFIGURATION);
		}

		@ConditionalOnProperty("ribbon.restclient.enabled")
		static class RibbonProperty {

		}

	}

}
```

## 网关文件上传限制

Zuul中有两个重要的类 **ZuulController** 和 **ZuulServlet** 

一般请求进来  DispatcherServlet.doDispatch()  -> ZuulController.handleRequest() -> ZuulServlet.service() -> 各种ZuulFilter

如果请求的地址是以 **/zuul** 开始（默认值，可以配置，此值就是注册ZuulServlet使用的拦截路径），则直接进入了 ZuulServlet.service()。（servlet的匹配规则）

因为文件上传限制是在 DispatcherServlet.doDispatch()是在这个方法校验的，所以要跳过这个逻辑只能把请求地址加上 /zuul。

改了之后测试的现象是RibbonRoutingFilter没有执行，导致不能正确调用下游服务。debug发现ctx.get(SERVICE_ID_KEY) 为空，各种ZuulFilter的shouldFilter()方法返回true才会执行run()方法逻辑。

```
public boolean shouldFilter() {
	RequestContext ctx = RequestContext.getCurrentContext();
	return (ctx.getRouteHost() == null && ctx.get(SERVICE_ID_KEY) != null && ctx.sendZuulResponse());
}
```

最初的解决方案是在执行RibbonRoutingFilter之前自定义一个route类型的 Filter，修改 SERVICE_ID_KEY ，在后续的过程中会报其他错误，具体原因是 ctx 中缺少其他的值。

后面的解决方法是debug用其他请求找到设置SERVICE_ID_KEY的地方，找到了PreDecorationFilter， 这个Filter 是pre 类型，在route 类型之前执行

```
public Object run() {
	RequestContext ctx = RequestContext.getCurrentContext();
	final String requestURI = this.urlPathHelper
			.getPathWithinApplication(ctx.getRequest());
	Route route = this.routeLocator.getMatchingRoute(requestURI);
	if (route != null) {
		String location = route.getLocation();
		if (location != null) {
			ctx.put(REQUEST_URI_KEY, route.getPath());
			ctx.put(PROXY_KEY, route.getId());
			if (!route.isCustomSensitiveHeaders()) {
				this.proxyRequestHelper.addIgnoredHeaders(
						this.properties.getSensitiveHeaders().toArray(new String[0]));
			}
			else {
				this.proxyRequestHelper.addIgnoredHeaders(
						route.getSensitiveHeaders().toArray(new String[0]));
			}

			if (route.getRetryable() != null) {
				ctx.put(RETRYABLE_KEY, route.getRetryable());
			}

			if (location.startsWith(HTTP_SCHEME + ":")
					|| location.startsWith(HTTPS_SCHEME + ":")) {
				ctx.setRouteHost(getUrl(location));
				ctx.addOriginResponseHeader(SERVICE_HEADER, location);
			}
			else if (location.startsWith(FORWARD_LOCATION_PREFIX)) {
				ctx.set(FORWARD_TO_KEY,
						StringUtils.cleanPath(
								location.substring(FORWARD_LOCATION_PREFIX.length())
										+ route.getPath()));
				ctx.setRouteHost(null);
				return null;
			}
			else {
				// set serviceId for use in filters.route.RibbonRequest
				ctx.set(SERVICE_ID_KEY, location);
				ctx.setRouteHost(null);
				ctx.addOriginResponseHeader(SERVICE_ID_HEADER, location);
			}
			if (this.properties.isAddProxyHeaders()) {
				addProxyHeaders(ctx, route);
				String xforwardedfor = ctx.getRequest()
						.getHeader(X_FORWARDED_FOR_HEADER);
				String remoteAddr = ctx.getRequest().getRemoteAddr();
				if (xforwardedfor == null) {
					xforwardedfor = remoteAddr;
				}
				else if (!xforwardedfor.contains(remoteAddr)) { // Prevent duplicates
					xforwardedfor += ", " + remoteAddr;
				}
				ctx.addZuulRequestHeader(X_FORWARDED_FOR_HEADER, xforwardedfor);
			}
			if (this.properties.isAddHostHeader()) {
				ctx.addZuulRequestHeader(HttpHeaders.HOST,
						toHostHeader(ctx.getRequest()));
			}
		}
	}
	else {
		log.warn("No route found for uri: " + requestURI);
		String forwardURI = getForwardUri(requestURI);

		ctx.set(FORWARD_TO_KEY, forwardURI);
	}
	return null;
}
```

可以看到，这里设置了很多值。debug发现之所以没有设置SERVICE_ID_KEY ，是因为这个方法开始获取Route的时候为空，所以只要保证这里能获取到Route后面的逻辑就和其他请求方式一样了。然后开始了修改requestURI的编码

```
@Slf4j
public class PreReplaceUrlFilter extends ZuulFilter {

    private static final PathMatcher PATH_MATCHER = new AntPathMatcher();

    @Autowired
    private ZuulProperties zuulProperties;
    @Autowired
    private UrlCustomProperties urlCustomProperties;
    
    @PostConstruct
    public void init() {
        log.info("servletPath = {}", zuulProperties.getServletPath());
        log.info("zuulServletUrl = {}", urlCustomProperties.getZuulServletUrl());
    }

    @Override
    public int filterOrder() {
        return PRE_DECORATION_FILTER_ORDER - 1;
    }

    @Override
    public String filterType() {
        return PRE_TYPE;
    }

    @Override
    public boolean shouldFilter() {
        RequestContext ctx = RequestContext.getCurrentContext();
        String url = ctx.getRequest().getRequestURI();
        if (!url.startsWith(zuulProperties.getServletPath())) {
            return false;
        }

        Set<String> set = urlCustomProperties.getZuulServletUrl();
        if (CollectionUtils.isEmpty(set)) {
            return false;
        }

        String newUrl = url.substring(zuulProperties.getServletPath().length());
        return set.contains(newUrl) || set.stream().anyMatch(s -> PATH_MATCHER.match(s, newUrl));
    }

    @Override
    public Object run() {
        RequestContext ctx = RequestContext.getCurrentContext();
        ctx.put(IS_DISPATCHER_SERVLET_REQUEST_KEY, Boolean.TRUE);
        HttpServletRequest request = ctx.getRequest();
        String originUrl = request.getRequestURI();
        String newUrl = originUrl.replaceFirst(zuulProperties.getServletPath(), zuulProperties.getPrefix());
        log.info("替换URL：{} => {}", originUrl, newUrl);
        ctx.setRequest(new ReplaceUrlHttpRequestWrapper(request, newUrl));
        return null;
    }


    private static class ReplaceUrlHttpRequestWrapper extends HttpServletRequestWrapper {

        private final String url;

        ReplaceUrlHttpRequestWrapper(HttpServletRequest request, String url) {
            super(request);
            this.url = url;
        }

        @Override
        public String getRequestURI() {
            return url;
        }

    }

}
```

- filterType 类型为 pre

- filterOrder 是PRE_DECORATION_FILTER_ORDER - 1，保证在PreDecorationFilter执行

- shouldFilter 是否执行，走配置文件，不能拦截所有的请求


run 方法有重要的一行 ctx.put(IS_DISPATCHER_SERVLET_REQUEST_KEY, Boolean.TRUE)，因为在debug的过程中发现如果没有这个属性，也获取不到route。具体使用的方法是org.springframework.cloud.netflix.zuul.filters.SimpleRouteLocator#adjustPath

附上一个最新的配置样例，包含超时的配置

```
url-custom:
    time-config:
        connect-timeout: 2000
        socket-timeout: 120000
        urlMap:
            ima-management:
                - '/{version}/pt/client/file/upload'  
    zuul-servlet-url:
        - '/ima-management/{version}/pt/client/file/upload'
```

> 最后：实际处理上传文件的应用的文件上传限制要满足
>
> --spring.cloud.nacos.config.ext-config[0].dataId=ima-management.yml
> --spring.cloud.nacos.config.ext-config[0].refresh=true